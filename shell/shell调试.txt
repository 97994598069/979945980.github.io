一、以下面的语句开场

set -o nounset
在默认情况下，遇到不存在的变量，会忽略并继续执行，而这往往不符合预期，加入该选项，可以避免恶果扩大，终止脚本的执行。
画外音：有些变量名的手误，会让人崩溃的调试半天，通过这个方式，这类手误秒发现。

set -o errexit
在默认情况下，遇到执行出错，会跳过并继续执行，而这往往不符合预期，加入该选项，可以避免恶果扩大，终止脚本的执行。
画外音：有些Linux命令，例如rm的-f参数可以强制忽略错误，此时脚本便无法捕捉到errexit，这样的参数在脚本里是不推荐使用的。


set -x    ##打开调试，分步执行
exec &> /tmp/log.txt   ##脚本执行的过程和结果导入/tmp/log.txt文件中


#!/bin/bash
set -o nounset
set -o errexit
这两个选项，都符合fail fast设计理念。



二、封装函数有必要
略


三、使用readonly和local修饰变量
readonly
顾名思义，只读。

local
函数内变量。

别图省事，提高安全性的同时，能避免很多让人崩溃的莫名其妙的错误。脚本写得专不专业，往往不是什么高深的点，从基本功绝逼能体现。



四、使用$()代替`(反单引号)
为什么？看了上面的例子你就懂了：
（1）$()能够支持内嵌；
（2）$()不用转义；
（3）有些字体，`(反单引号)和’(单引号)很像，容易把人搞晕；



五、使用[[]]代替[]
看出差别了么？[[]]更符合人性编码：
（1）避免转义问题；
（2）有不少新功能；

新功能包含但不限于：
|| ：逻辑or
&& ：逻辑and
< ：字符串比较（不需要转义）
== ：通配符(globbing)字符串比较
=~ ：正则表达式(regular expression, RegEx)字符串比较

t="abc123"
[[ "$t" == abc* ]]   true
[[ "$t" == "abc*" ]]  false
[[  "$t" = ~[abc]+[123]+ ]]  true 
[[ "$t" = ~"abc*" ]] false 

需要注意的是，从bash3.2开始，通配符和正则表达式都不能用引号包裹了（所以，上面的例子，加了引号就是字面比较）。
r="a b+"
[[ "a bbb" = ~$r ]] true 


六、echo不是唯一的调试方法
可以用-n对脚本进行语法检查。
bash -n myscripts.sh


可以用-v跟踪脚本里的每个命令的执行。
bash -v myscripts.sh 


以用-x跟踪脚本里的每个命令的执行，并附加扩充信息。
bash -x myscripts.sh 


当然，也可以在脚本里，添加
set -o verbose
set -o xtrace
来永久指定输出调试信息。
