CPU性能指标：
1) CPU使用率
cpu使用率描述了非空闲时间占总cpu时间的百分比，根据cpu上运行任务的不同，又被分为用户cpu、系统cpu、等待I/Ocpu、软中断和硬中断等
1.用户cpu使用率，包括用户态cpu使用率（user）和低优先级用户态cpu使用率（nice），表示cpu在用户态运行的时间百分比。用户cpu使用率高，通常说明有应用程序比较繁忙
2.系统cpu使用率，表示cpu在内核态运行的时间百分比（不包括中断）。系统cpu使用率高，说明内核比较繁忙
3.等待I/O的cpu使用率，通常也称为iowait，表示等待I/O的时间百分比。iowait高，通常说明系统与硬件设备的I/O交互时间比较长
4.软中断和硬中断的cpu使用率，分别表示内核调用软中断处理程序、硬中断处理程序的时间百分比。它们的使用率高，通常说明系统发生了大量的中断
5.除了上面这些，还有在虚拟化环境中会用到的窃取cpu使用率（steal）和客户cpu使用率（guest）,分别表示被其他虚拟机占用的cpu时间百分比，和运行客户虚拟机的cpu时间百分比

2) 平均负载
也就是系统的平均活跃进程数。它反应了系统的整体负载情况，主要包括三个数值，分别是过去1分钟、过去5分钟、过去15分钟的平均负载
理想情况下，平均负载等于逻辑cpu个数，这表示每个cpu都恰好被充分利用，如果平均负载大于逻辑cpu个数，就表示负载比较重了

3) 进程上下文切换
1.无法获取资源而导致的自愿上下文切换
2.被系统强制调度导致的非自愿上下文切换
上下文切换，本身是保证Linux正常运行的一项核心功能。但过多的上下文切换，会将原本运行进程的cpu时间，消耗在寄存器、内核栈以及虚拟内存等数据的保存和恢复上，缩短进程真正运行的时间，成为性能瓶颈

4) cpu缓存命中率
由于cpu发展速度远快于内存的发展，cpu的处理速度就比内存的访问速度快得多。这样，cpu在访问内存的时候，免不了要等待内存的响应。为了协调这两者的差距，cpu缓存就出现了




性能排查工具：
1)平均负载的案例
首先使用uptime查看平均负载
然后使用mpstat和pidstat分别观察每个cpu和每个进程cpu的使用情况，进而找出导致平均负载升高的进程，也就是我们的压测工具stress
mpstat -P ALL 5
pidstat -u 5 1

2)上下文切换的案例
首先使用vmstat，查看系统的上下文切换次数和中断次数，然后通过pidstat，观察进程的自愿上下文切换和非自愿上下文切换情况；最后通过pidstat，观察了线程的上下文切换情况，找出了上下文切换次数增多的根源，也就是我们的基准测试工具sysbench

3)进程cpu使用率升高的案例
首先使用top，查看系统和进程cpu使用情况，发现cpu使用率升高的进程是php-fpm；再用perf top，观察php-fpm调用链，最终找出cpu升高的根源，也就是库函数sqrt()

4)系统cpu使用率升高的案例
首先使用top观察到了系统cpu升高，但是通过top和pidstat,却找不出高cpu使用的进程。于是，我们重新审视了top的输出，又从cpu使用率不高但处于Running状态的进程入手，找出了可疑之处，最终通过perf record和oerf report发现了原来是短时进程在捣鬼
另外，短时进程还有一个专门的工具execsnoop,它可以实时监控进程调用的外部命令

5)不可中断进程和僵尸进程的案例
首先使用top观察到了iowait升高的问题，并发现了大量的不可中断进程和僵尸进程；接着我们用dstart发现这是由于磁盘读导致的，又通过pidstat找出了相关的进程。但我们使用strace查看进程系统却失败了，最终还是用perf分析进程调用链，才发现根源在于磁盘直接I/O没走I/O缓存造成的

6)软中断的案例
通过top观察到系统软中断cpu使用率升高；接着查看/proc/softirqs,找到了几种变化速率较快的软中断；然后通过sar命令，发现是网络小包的问题，最后再用tcpdump，找出网络帧的类型和来源，确定是一个SYN FLOOD攻击导致的


根据指标找工具：
1)平均负载 
uptime
top 

2)系统整体cpu使用率
vmstat 
mpstat 
top 
sar
/proc/stat 

3)进程cpu使用率 
top 
pidstat 
ps
htop
atop

4)系统上下文切换
vmstat 

5)进程上下文切换 
pidstat -w

6)软中断 
top 
/proc/softtirqs 

7)硬中断 
vmstat 
/proc/interrupts 

8)网络
dstat 
sar 
tcpdump

9)I/O 
dstat
sar 

10)cpu个数 
/proc/cpuinfo 
lscpu 

11)事件剖析
perf
execsnoop




top  vmstat pidstat 之间的联系：
top 的输出可以得到各种cpu使用率以及僵尸进程的平均负载等信息
vmstat的输出可以得到上下文切换次数、中断次数、运行状态和不可中断状态的进程数
pidstat的输出可以得到进程的用户cpu使用率、系统cpu使用率、以及自愿上下文切换和非自愿上下文切换情况

联系：
例子1:
pidstat输出的进程用户cpu使用率升高，会导致top输出的用户cpu使用率升高。所以，当发现top输出的用户cpu使用率有问题时，可以跟pidstat的输出做对比，观察是否是某个进程导致的问题
而找出导致性能问题的进程后，就要用进程分析工具来分析进程的行为，比如使用strace分析系统调用情况，以及使用perf分析调用链中各级函数的执行情况

例子2：
top输出的平均负载升高，可以跟vmstat输出的运行状态和不可中断状态的进程数做对比，观察是哪种进程导致的负载升高
1.如果是不可中断进程数增多了,那么就需要做I/O分析，也就是用dstat或sar等工具，进一步分析I/O的情况
2.如果是运行状态进程数增多了，那就需要回到top和pidstat,找出这些处于运行状态的到底是什么进程，然后再用进程分析工具，做进一步分析

例子3：
当top输出的软中断cpu使用率升高时，可以查看/proc/softitqs文件中各种类型软中断的变化情况，确定到底是哪种软中断类型出了问题。比如是网络接收中断导致的问题，那就可以继续用网络分析工具sar和tcpdump来分析














