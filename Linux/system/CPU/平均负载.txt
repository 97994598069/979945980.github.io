平均负载：
指单位时间内，系统处于可运行状态和不可中断状态的平均进程数，它和 CPU 使用率并没有直接关系

##可运行状态: 是指正在使用cpu或者正在等待cpu进程，也就是我们常用ps命令看到的。处于R状态（Running和Runnable）的进程
##不可中断状态：则是指正在处于内核态关键流程中的进程，并且这些流程是不可打断的，比如最常见的是等待硬件设备I/O响应，也就是我们在ps命令中看到的D状态（Uninterruptible Sleep,也被称为Disk Sleep）的进程
比如，当一个进程向磁盘读写数据时，为了保证数据的一致性，在得到磁盘回复前，它是不能被其他进程或者中断打断的，这个时候的进程处于不可中断状态，如果此时的进程被打断了，就容易出现磁盘数据与进程数据不一致的问题;;所以，不可中断状态实际上是系统对进程和硬件设备的一种保护机制



平均负载与CPU使用率：
平均负载是指单位时间内，处于可运行状态和不可中断状态的进程数，所以，它不仅包含了正在使用CPU的进程，还包括等待CPU和等待IO的进程
而CPU使用率，是单位时间内CPU繁忙情况的统计，跟平均负载并不一定完全对应：
比如：
CPU密集型进程， 使用大量CPU会导致平均负载升高，此时这两者是一致的
IO密集型进程，  等待I/O也会导致平均负载升高，但CPU使用率不一定很高
大量等待CPU的进程调度也会导致平均负载升高，此时的CPU使用率也会比较高



平均负载案例分析：
常用工具mpstat pidstat stress  (yum -y install epel-release && yum -y install sysstat stress)

stress是一个linux系统压力测试工具   sysstat是常用的Linux性能工具

mpstat是一个常用的多核CPU性能分析工具，用来实时查看每个CPU的性能指标，以及所有CPU的平均指标
pidstat是一个常用的进程性能分析工具，用来查看进程的CPU 内存 I/O以及上下文切换等性能指标



三个场景的测试：（CPU、IO、进程数）
备注：
每个场景都需要打开三个终端来进行测试查看

1)场景一：CPU密集型
stress --cpu 1 --timeout 600    ####在第一个终端模拟一个cpu使用率100%的场景

watch -d uptime   ###在第二个终端查看负载情况

mpstat -P ALL 5   ###在第三个终端查看CPU使用率的变化情况  
##-P ALL 表示监控所有CPU；5表示间隔5秒后输出一组数据

$ mpstat -P ALL 5
Linux 4.15.0 (ubuntu) 09/22/18 _x86_64_ (2 CPU)
13:30:06     CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle
13:30:11     all   50.05    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00   49.95
13:30:11       0    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00  100.00
13:30:11       1  100.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00

从终端二中可以看到，1 分钟的平均负载会慢慢增加到 1.00，而从终端三中还可以看到，正好有一个CPU的使用率为100%，但它的iowait只有0。这说明，平均负载的升高正是由于CPU使用率为100%


那么；到底是哪个进程呢？
# 间隔 5 秒后输出一组数据
$ pidstat -u 5 1
13:37:07      UID       PID    %usr %system  %guest   %wait    %CPU   CPU  Command
13:37:12        0      2962  100.00    0.00    0.00    0.00  100.00     1  stress

从这里可以看到运行stress的进程的CPU使用率为100%



场景二：I/O密集型进程
同理：
$ stress -i 1 --timeout 600

$ watch -d uptime
...,  load average: 1.06, 0.58, 0.37


# 显示所有 CPU 的指标，并在间隔 5 秒输出一组数据
$ mpstat -P ALL 5 1
Linux 4.15.0 (ubuntu)     09/22/18     _x86_64_    (2 CPU)
13:41:28     CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle
13:41:33     all    0.21    0.00   12.07   32.67    0.00    0.21    0.00    0.00    0.00   54.84
13:41:33       0    0.43    0.00   23.87   67.53    0.00    0.43    0.00    0.00    0.00    7.74
13:41:33       1    0.00    0.00    0.81    0.20    0.00    0.00    0.00    0.00    0.00   98.99

从这里可以看到1分钟的平均负载会慢慢增加到1.06，其中一个cpu的系统cpu使用率升高到了23.87，而iowait高达67.53%；这说明；平均负载的升高时由于iowait的升高

# 间隔 5 秒后输出一组数据，-u 表示 CPU 指标
$ pidstat -u 5 1
Linux 4.15.0 (ubuntu)     09/22/18     _x86_64_    (2 CPU)
13:42:08      UID       PID    %usr %system  %guest   %wait    %CPU   CPU  Command
13:42:13        0       104    0.00    3.39    0.00    0.00    3.39     1  kworker/1:1H
13:42:13        0       109    0.00    0.40    0.00    0.00    0.40     0  kworker/0:1H
13:42:13        0      2997    2.00   35.53    0.00    3.99   37.52     1  stress
13:42:13        0      3057    0.00    0.40    0.00    0.00    0.40     0  pidstat

同理可以查看得到时stress进程导致的




场景三：大量进程的场景
当系统中运行进程超过CPU运行能力时，就会出现等待cpu的进程

同理测试：
$ stress -c 8 --timeout 600
##由于系统只有2个cpu，明显比8个进程要少得多，因而，系统的cpu处于严重过载状态，平均负载高达7.97

$ uptime
...,  load average: 7.97, 5.93, 3.02


# 间隔 5 秒后输出一组数据
$ pidstat -u 5 1
14:23:25      UID       PID    %usr %system  %guest   %wait    %CPU   CPU  Command
14:23:30        0      3190   25.00    0.00    0.00   74.80   25.00     0  stress
14:23:30        0      3191   25.00    0.00    0.00   75.20   25.00     0  stress
14:23:30        0      3192   25.00    0.00    0.00   74.80   25.00     1  stress
14:23:30        0      3193   25.00    0.00    0.00   75.00   25.00     1  stress
14:23:30        0      3194   24.80    0.00    0.00   74.60   24.80     0  stress
14:23:30        0      3195   24.80    0.00    0.00   75.00   24.80     0  stress
14:23:30        0      3196   24.80    0.00    0.00   74.60   24.80     1  stress
14:23:30        0      3197   24.80    0.00    0.00   74.80   24.80     1  stress
14:23:30        0      3200    0.00    0.20    0.00    0.20    0.20     0  pidstat

##可以看出，8个进程在争抢2个CPU,每个进程等待cpu的时间（也就是代码块中的%wait列）高达75%。这些超出cpu计算能力的进程，最终导致cpu过载








































