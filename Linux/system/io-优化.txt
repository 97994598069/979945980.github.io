文件系统就是用来组织数据的。就是将i节点和block组织在一起 

i节点   文件的元数据  其实就是一个指针 
每个分区最开始会存放一个i节点表，一个文件对应一个i节点，里面存放对应该文件的block  数据删除了 就把文件和block关联删除就行了。
block   存放数据  

io分层
applications
 【下面的都是由内核维护的】
file systems       stat命令文件的元数据信息  查看文件的元数据【device  inode】dumpe2fs
page cache       内存中的一块 【buffer cached】
BIO 将上层过来的请求进行合并和排序
伪设备 管理lvm raid
物理设备  磁盘

应用程序具备组织数据的能力就可以不使用文件系统了  mysql  oracle 


系统调用   介于应用程序  和文件系统之间
追踪系统调用 strace
strace cat /etc/passwd  
  open  打开一个文件   （）= n   n是一个文件描述符  可以理解为文件的身份证号

   read()=n   读文件大小
   write   写操作   写到屏幕
   close 关闭操作


dumpe2fs /dev/sda1 -h
让buffer cached 增长
dd if=/dev.zero of=/tmp/bigfile bs=1M count=200  写操作
dd if=/tmp/bigfile of=/dev/null    读操作  第一次慢 第二次快 第二次走了page cache



HD 定位时间【和 转速 相关】    读取数据时间
  15000rpm  大概需要定位时间6ms   1s=1000ms
   6ms  seek time  寻道时间
 一个IO分为两部分  1.seek time 2.从磁盘读写数据的时间
 IOPS 每秒发生的IO次数  1000MS/一个IO的时间 
 throughput 吞吐量       单位为（m/s  G/s）

  page cache  其实就是内存上空闲的部分  用来缓存数据，比如buffer cache

为什么实际HD读写没有理论的高
  厂商测试的时理论  是顺序读写  也就是一次IO一次seek time
而 现实是随机读写 seek time不可控制   可多可少  零碎文件越多seek time越多 
   一个文件夹   一个电影     


BIO  磁盘读写排序 合并   然后再发给物理设备   尽可能保证顺序读写  坐电梯
  比如 4 3 3 4 2 2  人坐电梯   去几楼
  电梯排序  2 2 3 3 4 4
   电梯
磁盘阵列 是将一个IO分到多个设备  所以seektime减少了  所以快了
  

通过GRUB实现内核调优
 
A=B   关键字=赋值
IO调度器优化
elevator=deadline
调度算法
noop anticipatory deadline [cfq]
deadline :    deadline 算法保证对既定的IO请求以最小的延迟时间。 时效性强，响应性最好 web  数据库
anticipatory：    有个IO发生后，如果又有进程请求IO，则产生一个默认6ms猜测时间，猜测下一个进程请求IO是干什么。这对于随机读取会造成较大的延时。
        对数据库应用很糟糕，而对于Web Server等则会表现不错。
       下载服务器    关心吞吐量   预期算法
cfq:        对每个进程维护一个IO队列，各个进程发来的IO请求会被cfq以轮循方式处理，对每一个IO请求都是公平。适合离散读的应用。完全公平，如果有大量进程
noop:        对所有IO请求都用FIFO队列形式处理。默认IO不会存在性能问题。固态硬盘使用
改变调度器
$ echo deadline > /sys/block/sdX/queue/scheduler 
对于数据库服务器，deadline算法是推荐的。
提高调度器请求队列的
$ echo 4096 > /sys/block/sdX/queue/nr_requests     



iostat   -xm 5 2

x 详细信息
m 以M显示  默认块

avgqu-sz  平均队列长度2-3 代表饱和  超过就忙不过来
用dd模拟一次读   看下
avgrq-sz 平均请求大小  单位为扇区
%util  数值越大代表IO越忙
r/s  每秒发送的读请求
w/s每秒发送的写请求
r/s+w/s就是每秒的iops/s  

rMB/s每秒读的大小
wMB/s每秒写得大小     单位MB
rMB/s + wMB/s  = 吞吐量/s

rrqm/s 每秒合并读请求
wrqm/s 每秒合并写请求

测试  让IO忙
通过NFS共享一个目录   让客户端远端挂载 里面放个大文件  客户端同时下载该大文件  IO就忙了


IO压力测试
找到极限  让后设置阈值   

1.监控项
监控需要监控  avgqu-sz  iowait throughput[吞吐量] 
                       大文件顺序读压测
                       小文件   随机读压测
             file system（分区是否有可用空间）
2. 阈值
avgqu-sz   2-3
  iowait throughput[吞吐量]   极限的80%    iozne
                       大文件顺序读压测
                       小文件   随机读压测
             file system（分区是否有可用空间）
3.定位问题  atop 第三方插件  可以找出谁把你IO搞忙了
4.解决问题
         如果是apache 大了  有人在砍站【直接将你网站全部下载下来】
          如何判断是否被砍站   分析日志  同一个IP访问了大量页面

一次会话默认最多同时使用1024个文件描述符  ulimit -n

ab -n 100000 -c 1025 http://ip/index.html

报错：socket: too many open files
vim  /etc/secureity/limits.conf
* hard nofile 102400
* soft nofile   102400  
新会话开始生效  
当前会话立马生效  ulimit -HSn 102400

5.减少IO操作 Apache为例
考虑关闭访问日志  慎重 
针对WEB   关闭atime 
文件系统 ext2  or ext3




vmstat命令是最常见的Linux/Unix监控工具，可以展现给定时间间隔的服务器的状态值,包括服务器的CPU使用率，内存使用，虚拟内存交换情况,IO读写情况。这个命令是我查看Linux/Unix最喜爱的命令，一个是Linux/Unix都支持，二是相比top，我可以看到整个机器的CPU,内存,IO的使用情况，而不是单单看到各个进程的CPU使用率和内存使用率(使用场景不一样)。

一般vmstat工具的使用是通过两个数字参数来完成的，第一个参数是采样的时间间隔数，单位是秒，第二个参数是采样的次数，如:

root@ubuntu:~# vmstat 21
procs -----------memory---------- ---swap-- -----io---- -system-- ----cpu----
 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa
10034984723158363819540000120001000
如果查看的时候请多采集几次数据 第一次是从开机到现在，实时的从第二次开始看

2表示每个两秒采集一次服务器状态，1表示只采集一次。

实际上，在应用过程中，我们会在一段时间内一直监控，不想监控直接结束vmstat就行了,例如:


root@ubuntu:~# vmstat 2
procs -----------memory---------- ---swap-- -----io---- -system-- ----cpu----
 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa
10034998403158363819660000120001000
00034995843158363819660000088158001000
00034997083158363819660000286162001000
000349970831583638196600001081151001000
10034997323158363819660000283154001000

这表示vmstat每2秒采集数据，一直采集，直到我结束程序，这里采集了5次数据我就结束了程序。

好了，命令介绍完毕，现在开始实战讲解每个参数的意思。

r 表示运行队列(就是说多少个进程真的分配到CPU)，我测试的服务器目前CPU比较空闲，没什么程序在跑，当这个值超过了CPU数目，就会出现CPU瓶颈了。这个也和top的负载有关系，一般负载超过了3就比较高，超过了5就高，超过了10就不正常了，服务器的状态很危险。top的负载类似每秒的运行队列。如果运行队列过大，表示你的CPU很繁忙，一般会造成CPU使用率很高。

b 表示阻塞的进程,这个不多说，进程阻塞，大家懂的。

swpd 虚拟内存已使用的大小，如果大于0，表示你的机器物理内存不足了，如果不是程序内存泄露的原因，那么你该升级内存了或者把耗内存的任务迁移到其他机器。

free   空闲的物理内存的大小，我的机器内存总共8G，剩余3415M。

buff   Linux/Unix系统是用来存储，目录里面有什么内容，权限等的缓存，我本机大概占用300多M

cache cache直接用来记忆我们打开的文件,给文件做缓冲，我本机大概占用300多M(这里是Linux/Unix的聪明之处，把空闲的物理内存的一部分拿来做文件和目录的缓存，是为了提高 程序执行的性能，当程序使用内存时，buffer/cached会很快地被使用。)

si  每秒从磁盘读入虚拟内存的大小，如果这个值大于0，表示物理内存不够用或者内存泄露了，要查找耗内存进程解决掉。我的机器内存充裕，一切正常。   swap_in

so  每秒虚拟内存写入磁盘的大小，如果这个值大于0，同上。    swap_out

bi  块设备每秒接收的块数量，这里的块设备是指系统上所有的磁盘和其他块设备，默认块大小是1024byte，我本机上没什么IO操作，所以一直是0，但是我曾在处理拷贝大量数据(2-3T)的机器上看过可以达到140000/s，磁盘写入速度差不多140M每秒

bo 块设备每秒发送的块数量，例如我们读取文件，bo就要大于0。bi和bo一般都要接近0，不然就是IO过于频繁，需要调整。

in 每秒CPU的中断次数，包括时间中断

cs 每秒上下文切换次数，例如我们调用系统函数，就要进行上下文切换，线程的切换，也要进程上下文切换，这个值要越小越好，太大了，要考虑调低线程或者进程的数目,例如在apache和nginx这种web服务器中，我们一般做性能测试时会进行几千并发甚至几万并发的测试，选择web服务器的进程可以由进程或者线程的峰值一直下调，压测，直到cs到一个比较小的值，这个进程和线程数就是比较合适的值了。系统调用也是，每次调用系统函数，我们的代码就会进入内核空间，导致上下文切换，这个是很耗资源，也要尽量避免频繁调用系统函数。上下文切换次数过多表示你的CPU大部分浪费在上下文切换，导致CPU干正经事的时间少了，CPU没有充分利用，是不可取的。

us 用户CPU时间，我曾经在一个做加密解密很频繁的服务器上，可以看到us接近100,r运行队列达到80(机器在做压力测试，性能表现不佳)。

sy 系统CPU时间，如果太高，表示系统调用时间长，例如是IO操作频繁。

id  空闲 CPU时间，一般来说，id + us + sy = 100,一般我认为id是空闲CPU使用率，us是用户CPU使用率，sy是系统CPU使用率。

wt 等待IO CPU时间。 等待越大说明IO有问题 结合bi bo 来看

