同CPU一样，内存管理也是操作系统最核心的功能之一，
内存主要用来存储系统和应用程序的指令、数据、缓存等

一般来说只有内核才能直接访问物理内存。那么进程要访问内存时，该怎么办呢？
Linux内核给每个进程都提供了一个独立的虚拟地址空间，并且这个地址空间是连续的。这样，进程就可以很方便地访问内存，更确切地说是访问虚拟内存

虚拟地址空间的内部又被分为内核空间和用户空间两部分，不同字长(也就是单个cpu指令可以处理数据的最大长度)的处理器，地址空间的范围不同。比如最常见的32位系统和54位系统

进程在用户态时，只能访问用户空间内存；只有进入内核态后，才能访问内核空间内存。虽然每个进程的地址空间都包含了内核空间，单这些内核空间，其实关联的都是相同的物理内存。这样进程切换到内核态后，就可以很方便地访问内核空间内存

但是既然每个进程都有一个这么大的地址空间，那么所有进程的虚拟内存加起来，自然要比实际的物理内存大得多。所以。并不是所有的虚拟内存都会分配物理内存，只有那些实际使用的虚拟内存才分配物理内存，并且分配后的物理内存，是通过内存映射来管理的


内存映射，其实就是将虚拟内存地址映射到物理内存地址。为了完成内存映射，内核为每个进程都维护了一张页表，记录虚拟地址与物理地址的映射关系；；页表实际上存储在cpu的内存管理单元MMU中，这样，正常情况下，处理器就可以直接通过硬件，找出要访问的内存；；而当进程访问的虚拟地址在页表中查不到时，系统会产生一个缺页异常，进入内核空间分配物理内存、更新进程页表，最后再返回用户空间，恢复进程的运行





内存分配与回收
malloc()是C标准库提供的内存分配函数，对应到系统调用上，有两种实现方式，即brk()和mmap()

对于小块内存(小于128K)，C标准库使用brk()来分配，也就是通过移动堆顶的位置来分配内存。这些内存释放后并不会立刻归还系统，而是被缓存起来，这样就可以重复使用
对于大块内存(大于128K)，则直接使用内存映射mmap()来分配，也就是在文件映射段找一块空闲内存分配出去

这两种方式各自的优缺点：
1)brk()方式的缓存，可以减少缺页异常的发生，提高内存访问效率，不过这些内存没有归还系统，在内存工作繁忙时，频繁的内存分配和释放会造成内存碎片

2)而mmap()方式分配的内存，会在释放时直接归还系统，所以每次mmap都会发生缺页异常。在内存工作繁忙时，频繁的内存分配会导致大量的缺页异常，使内核的管理负担增大，这也是malloc只对大块内存使用mmap的原因

上述这两种调用发生后，其实并没有真正分配内存。这些内存，都只在首次访问时才分配，也就是通过缺页异常进入内核中，再由内核来分配内存

整体来说，Linux使用伙伴系统来管理内存分配，这些内存在MMU中以页为单位进行管理，伙伴系统也是一样，以页为单位来管理内存，并且会通过相邻页的合并，减少内存碎片化（比如brk方式造成的内存碎片）

但是如果遇到比页更小的对象，比如不到1K的时候，应该怎么分配内存呢？
实际系统运行中，确实有大量比页还小的对象，如果为他们也分配单独的页，那就太浪费内存了。所以在用户空间，malloc通过brk()分配的内存，在释放时并不立即归还系统，而是缓存起来重复利用，在内核空间，Linux通过slab分配器来管理小内存。你可以把slab看成构建在伙伴系统上的一个缓存，主要作用是分配并释放内核中的小对象

对于内存来说，如果只分配不释放，就会造成内存泄漏，甚至会耗尽系统内存。所以，在应用程序用完内存后，还需要调用free()或unmap(),来释放这些不用的内存

当然，系统也不会任由某个进程用完所有内存，当发现内存紧张时，系统就会通过一系列机制来回收内存，比如下面三种方式:
1) 回收缓存，比如使用LRU(Least Recentry Used)算法，回收最近使用最少的内存页面
2) 回收不常访问的内存，把不常用的内存通过交换分区直接写到磁盘中
3) 杀死进程，内存紧张时系统还会通过OOM(out of memory),直接杀掉占用大量内存的进程

上述第(2)种回收不常访问内存时，会用到交换分区(以下简称Swap)。swap其实就是把一块磁盘空间当成内存来用。它可以把进程暂时不用的数据存储到磁盘中(这个过程称为换出)，当进程访问这些内存时，再从磁盘读取这些数据到内存中(这个过程称为换入)；所以你可以发现，swap把系统的可用内存变大了，不过要注意，通常只在内存不足时，才会发生swap交换。并且由于磁盘读写速度远比内存慢，swap会导致严重的内存性能问题

上述第(3)种 OOM（out of memory）,其实是内核的一种保护机制，它监控进程的内存使用情况，并且使用oom+score为每个进程的内存使用情况进行评分：
1.一个进程消耗的内存越大，oom_score就越大
2.一个进程运行占用的cpu越多，oom_score就越小
这样，进程的oom_score越大，代表消耗的内存越多，也就越容易被oom杀死，从而可以更好保护系统
当然，为了实际工作需要，管理员可以通过/proc文件系统，手动设置进程的oom_adj,从而调整进程的oom_score
oom_adj的范围是[-17,15],数值越大，表示进程越容易被oom杀死；数值越小，表示进程越不容易被oom杀死，其中-17表示禁止oom
示例： 将sshd进程oom_adj调小为-16，这样，sshd进程就不容易被oom杀死
echo -16 > /proc/$(pidof sshd)/oom_adj



top输出：
VIRT是进程虚拟内存的大小，只要是进程申请过得内存，即便还没有真正分配物理内存，也会计算在内
RES 是常驻内存的大小，也就是进程实际使用的物理内存大小，但不包括swap和共享内存
SHR 是共享内存的大小，比如与其他进程共同使用的共享内存、加载的动态链库以及程序的代码段等
%MEM 是进程使用物理内存占系统内存的百分比

需注意两点：
1.虚拟内存通常并不会全部分配物理内存，从输出上看，可以发现每个进程的虚拟内存都比常驻内存大得多
2.共享内存SHR并不一定是共享的，比如说，程序的代码段、非共享的动态链接库，也都算在SHR里。当然，SHR也包括了进程间真正共享的内存。所以在计算多个进程的内存使用时，不要把所有进程的SHR直接相加得出结果








