free 

结果输出包含了内存mem和交换分区swap的具体使用情况，比如总内存、已用内存、缓存、可用内存等，其中缓存是buffer和cache两部分的总和

buffer和cache的区别：
buffers是内核缓冲区用到的内存，对应的是/proc/meminfo中的buffers值
cache是内核页缓存和slab用到的内存，对应的是/proc/meminfo中的cached与SReclaimable之和


buffers是对原始磁盘块的临时存储，也就是用来缓存磁盘的数据，通常不会特别大(20MB左右)。这样，内核就可以把分散的写集中起来，统一优化磁盘的写入，比如可以把多次小的写合并成单次大的写等
cached是从磁盘读取文件的页缓存，也就是用来缓存从文件读取的数据。这样，下次访问这些文件数据时，就可以直接从内存中快速获取，而不需要再次访问缓慢的磁盘
SReclaimable是slab的一部分。slab包括两部分，其中的可回收部分，用SReclaimable记录，而不可回收部分，用SUnreclaim记录


问题一，buffer只是将要写入磁盘数据的缓存，那反过来，它会不会也缓存从磁盘中读取的数据呢？
问题二，cache是从文件读取数据的缓存，那它是不是也会缓存写文件的数据呢？

案例：
为了减少缓存的影响，需要先清理缓存：
# 清理文件页、目录项、Inodes 等各种缓存
$ echo 3 > /proc/sys/vm/drop_caches   ###写入3表示清理文件页、目录页、Inodes等各种缓存

场景一：磁盘和文件写案例
在第一个终端运行：
# 每隔 1 秒输出 1 组数据
$ vmstat 1
procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
0  0      0 7743608   1112  92168    0    0     0     0   52  152  0  1 100  0  0
 0  0      0 7743608   1112  92168    0    0     0     0   36   92  0  0 100  0  0
 
需要关注：buffer和cache，以及io部分的bi和bo
buffer和cache就是我们前面看到的buffers和cache，单位是KB
bi和bo则分别表示块设备读取和写入的大小，单位为块/秒。因为Linux中块的大小是1KB，所以这个单位也就等价于KB/s 

正常情况下，空闲系统中，你应该看到的是这几个值在多次结果中一直保持不变

接下来在第二个终端执行dd命令，通过读取随机设备，生成一个500MB大小的文件：
$ dd if=/dev/urandom of=/tmp/file bs=1M count=500

然后再次回到第一个终端，观察buffer和cache的变化：
procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
0  0      0 7499460   1344 230484    0    0     0     0   29  145  0  0 100  0  0
 1  0      0 7338088   1752 390512    0    0   488     0   39  558  0 47 53  0  0
 1  0      0 7158872   1752 568800    0    0     0     4   30  376  1 50 49  0  0
 1  0      0 6980308   1752 747860    0    0     0     0   24  360  0 50 50  0  0
 0  0      0 6977448   1752 752072    0    0     0     0   29  138  0  0 100  0  0
 0  0      0 6977440   1760 752080    0    0     0   152   42  212  0  1 99  1  0
...
 0  1      0 6977216   1768 752104    0    0     4 122880   33  234  0  1 51 49  0
 0  1      0 6977440   1768 752108    0    0     0 10240   38  196  0  0 50 50  0
通过对比观察发现，cache在不停的增长，而buffer基本保持不变

再进一步观察I/O的情况：
1.在cache刚开始增长时，块设备I/O很少，bi只出现了一次488KB/s,bo则只有一次4KB。而过一段时间后，才会出现大量的块设备写，比如bo变成了122880。
2.当dd命令结束后，cache不再增长，但块设备写还会持续一段时间，并且，多次I/O写的结果加起来，才是dd要写的500M数据

cache是文件读的页缓存，怎么现在写文件页有它的份？
案例2：
# 首先清理缓存
$ echo 3 > /proc/sys/vm/drop_caches
# 然后运行 dd 命令向磁盘分区 /dev/sdb1 写入 2G 数据
$ dd if=/dev/urandom of=/dev/sdb1 bs=1M count=2048

procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
1  0      0 7584780 153592  97436    0    0   684     0   31  423  1 48 50  2  0
 1  0      0 7418580 315384 101668    0    0     0     0   32  144  0 50 50  0  0
 1  0      0 7253664 475844 106208    0    0     0     0   20  137  0 50 50  0  0
 1  0      0 7093352 631800 110520    0    0     0     0   23  223  0 50 50  0  0
 1  1      0 6930056 790520 114980    0    0     0 12804   23  168  0 50 42  9  0
 1  0      0 6757204 949240 119396    0    0     0 183804   24  191  0 53 26 21  0
 1  1      0 6591516 1107960 123840    0    0     0 77316   22  232  0 52 16 33  0

观察发现，虽然同是写数据，写磁盘跟写文件的现象还是不同的。写磁盘时(也就是bo大于0时)，buffer和cache都在增长，但显然buffer的增长快得多
这说明，写磁盘用到了大量的buffer

对比上述两个案例发现：写文件时会用到cache缓存数据，而写磁盘则会用到buffer来缓存数据；；虽然文档上说cache是文件读的缓存，但是实际上，cache也会缓存写文件的数据





场景2：磁盘和文件读案例
# 首先清理缓存
$ echo 3 > /proc/sys/vm/drop_caches
# 运行 dd 命令读取文件数据
$ dd if=/tmp/file of=/dev/null


procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
 0  1      0 7724164   2380 110844    0    0 16576     0   62  360  2  2 76 21  0
 0  1      0 7691544   2380 143472    0    0 32640     0   46  439  1  3 50 46  0
 0  1      0 7658736   2380 176204    0    0 32640     0   54  407  1  4 50 46  0
 0  1      0 7626052   2380 208908    0    0 32640    40   44  422  2  2 50 46  0

观察vmstat的输出，会发现读取文件时(也就是bi大于0时)，buffer保持不变，而cache则在不停的增长。
 
 
磁盘读是什么情况呢？
# 首先清理缓存
$ echo 3 > /proc/sys/vm/drop_caches
# 运行 dd 命令读取文件
$ dd if=/dev/sda1 of=/dev/null bs=1M count=1024


procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
0  0      0 7225880   2716 608184    0    0     0     0   48  159  0  0 100  0  0
 0  1      0 7199420  28644 608228    0    0 25928     0   60  252  0  1 65 35  0
 0  1      0 7167092  60900 608312    0    0 32256     0   54  269  0  1 50 49  0
 0  1      0 7134416  93572 608376    0    0 32672     0   53  253  0  0 51 49  0
 0  1      0 7101484 126320 608480    0    0 32748     0   80  414  0  1 50 49  0

观察vmstat的输出，你会发现读磁盘时(也就是bi大于0时)，buffer和cache都在增长，但显然buffer的增长快很多，说明读磁盘时，数据缓存到了buffer中

1. buffer既可以用作"将要写入磁盘数据的缓存"，也可以用作"从磁盘读取数据的缓存" 
2. cache既可以用作"从文件读取数据的页缓存", 也可以用作"写文件的页缓存"



从写的角度来说，不仅可以优化磁盘和文件的写入，对应用程序也有好处，应用程序可以在数据真正罗盘前，就返回去做其他工作
从读的角度来说，既可以加速读取哪些需要频繁访问的数据，也降低了频繁I/O对磁盘的压力



















 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 




