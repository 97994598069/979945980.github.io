四种死锁情况:
在InnoDB中，使用行锁机制，于是，锁通常是逐步获得的，这就决定了在InnoDB中发生死锁是可能的。
即将分享的四种死锁的锁冲突分别是：不同表的相同记录 行索引锁冲突、主键索引锁冲突、主键索引锁与非聚簇索引锁冲突、锁升级造成锁队列阻塞。

不同表的相同记录行锁冲突
案例：两个表、两行记录，交叉获得和申请互斥锁
条件：
A、 两事务分别操作两个表、相同表的同一行记录
B、 申请的锁互斥
C、 申请的顺序不一致



主键索引锁冲突
案例：本文案例，产生冲突在主键索引锁上
条件：
A、 两sql语句即两事务操作同一个表、使用不同索引
B、 申请的锁互斥
C、 操作多行记录
D、 查找到记录的顺序不一致



主键索引锁与非聚簇索引锁冲突
案例：同一行记录，两事务使用不同的索引进行更新操作
此案例涉及TSK_TASK表，该表相关字段及索引如下：
ID：主键；
MON_TIME：监测时间；
STATUS_ID：任务状态；
索引：KEY_TSKTASK_MONTIME2 (STATUS_ID, MON_TIME)。

条件：
A、 两事务使用不同索引
B、 申请的锁互斥
C、 操作同一行记录
当执行update、delete操作时，会修改表中的数据信息。由于innodb存储引擎中索引的数据存储结构，会根据修改语句使用的索引以及修改信息 的不同执行不同的加锁顺序。当使用索引进行查找并修改记录时，会首先加使用的索引锁，然后，如果修改了主键信息，会加主键索引锁和所有非聚簇索引锁，修改 了非聚簇索引列值会加该种非聚簇索引锁。
此案例中，事务一使用非聚簇索引查找并修改主键值，事务二使用主键索引查找并修改主键值，加锁顺序不同，导致同时运行时产生资源循环等待。


锁升级造成锁队列阻塞
案例：同一行记录，事务内进行锁升级，与另一等待锁发送锁队列阻塞，导致死锁
条件：
A、 两事务操作同一行记录
B、 一事务对某一记录先申请共享锁，再升级为排他锁
C、 另一事务在过程中申请这一记录的排他锁

避免死锁的方法
InnoDB给MySQL提供了具有提交，回滚和崩溃恢复能力的事务安全（ACID兼容）存储引擎。InnoDB锁定在行级并且也在SELECT语句提供非锁定读。这些特色增加了多用户部署和性能。
但其行锁的机制也带来了产生死锁的风险，这就需要在应用程序设计时避免死锁的发生。以单个SQL语句组成的隐式事务来说，建议的避免死锁的方法如下：
1.如果使用insert…select语句备份表格且数据量较大，在单独的时间点操作，避免与其他sql语句争夺资源，或使用select into outfile加上load data infile代替 insert…select，这样不仅快，而且不会要求锁定
2. 一个锁定记录集的事务，其操作结果集应尽量简短，以免一次占用太多资源，与其他事务处理的记录冲突。
3.更新或者删除表格数据，sql语句的where条件都是主键或都是索引，避免两种情况交叉，造成死锁。对于where子句较复杂的情况，将其单独通过sql得到后，再在更新语句中使用。
4. sql语句的嵌套表格不要太多，能拆分就拆分，避免占有资源同时等待资源，导致与其他事务冲突。
5. 对定点运行脚本的情况，避免在同一时间点运行多个对同一表进行读写的脚本，特别注意加锁且操作数据量比较大的语句。
6.应用程序中增加对死锁的判断，如果事务意外结束，重新运行该事务，减少对功能的影响。


MySQL死锁分析
当程序并发update同一张表，或者并发insert 一张表的时候都会出现数据库死锁问题。当并发insert一张表可能会出现间隙锁（小概率事件），这里先不谈，我主要描述update的常见的一种场景。
开启mysql死锁监控
create table InnoDB_monitor(a INT) engine=InnoDB;
linux 环境重启myql

查死锁信息
查看死锁日志
在linux系统中：
先用 root 账号登录 mysql -uroot -proot。
然后用命令查看死锁信息 show engine innodb status \G;

在日志中找 LATEST DETECTED DEADLOCK 字样的日志，就是死锁日志。下面是我整理并截取的部分日志
